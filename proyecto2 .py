# -*- coding: utf-8 -*-
"""proyecto2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q0Qk8pW6AahQwfpOxRY-kqc3NRZWSRFP
"""

#Se guradan los nodos a utilizar
class Nodo:

    def __init__(self, i):
        self.id=i
        self.visitado=False
        self.nivel = -1
        self.padre = None
        self.vecinos =[]# Genera la lista de vecinos que tiene cada nodo 

    #Cargo la lista de vecinos que se genera
    def agregarVecino(self, v):
        if not v in self.vecinos:
            self.vecinos.append(v)
    
class Grafo:
    def __init__(self):
        self.vertices ={} #key: id == key, lista identicadores del nodo que son sus vecinos
        self.storeR = []
        self.storefs = []
    #Genero la lista de nodos que tengo
    def agregaNodo(self, v):
        if v not in self.vertices:
            self.vertices[v]= Nodo(v) 
    
    def agregarAristas(self, a, b):
        if a in self.vertices and b in self.vertices:
            self.vertices[a].agregarVecino(b)
            self.vertices[b].agregarVecino(a)
    #Recorre el grafo a lo ancho
    def bfs(self, r):
        storebfs = []
        if r in self.vertices:
            cola = [r]

            self.vertices[r].visitado = True
            self.vertices[r].nivel = 0
            print("(" + str(r) + ", " + str(self.vertices[r].nivel)+ ")")
            while( len(cola) > 0):
                act = cola[0]
                cola = cola[1:]

                for v in self.vertices[act].vecinos:
                    if self.vertices[v].visitado == False:
                        cola.append(v)
                        self.vertices[v].visitado = True
                        self.vertices[v].nivel = self.vertices[act].nivel + 1
                        storebfs.append((v, self.vertices[v].nivel))
                        print("(" + str(v) + ", " + str(self.vertices[v].nivel)+ ")")
        self.storeR = storebfs
        print(self.storeR)
    #recorre Grafo a lo profundo iniciando por el lado izquierdo
    def dfs_L(self, r):
        
        if r in self.vertices:
            self.vertices[r].visitado = True
            d = self.vertices[r].vecinos
            l = len(self.vertices[r].vecinos)-1
            
            newlista= []
            while(l >= 0):
                newlista.append(d[l])
                l=l-1
            for nodo in newlista:
                
                if self.vertices[nodo].visitado == False:
                    self.vertices[nodo].padre = r
                    self.storefs.append((r, nodo))
                    print("(" + str(r) + ", " + str(nodo) + ")")
                    self.dfs_L(nodo)
        self.storeR = self.storefs
    #recorre Grafo a lo profundo iniciando por el lado izquierdo
    
    def dfs_R(self, r):
        
        if r in self.vertices:          
            self.vertices[r].visitado = True
            for nodo in self.vertices[r].vecinos:               
                if self.vertices[nodo].visitado == False:
                    self.vertices[nodo].padre = r
                    self.storefs.append((r, nodo))
                    print("(" + str(r) + ", " + str(nodo) + ")")
                    self.dfs_R(nodo)
        self.storeR = self.storefs

    #Regrese a cada nodo a false para poder hacer un nuevo recorrido
    def resetear(self, n):
          
        for nodo in range(0, n):
            self.vertices[nodo].visitado = False 

class Biblioteca:
    
    def __init__(self):
        self.listaAristas = []

    #Modelo Gm,n de malla. Crear m*n nodos. Para el nodo ni,j crear una arista con el nodo ni+1,j
    # y otra con el nodo ni,j+1, para i<m y j<n
    def grafoMalla(self, n, m, dirigido=False):
            
        """
        Genera grafo de malla
        :param m: número de columnas (> 1)
        :param n: número de filas (> 1)
        :param dirigido: el grafo es dirigido?
        :return: grafo generado
        """
        coordenada = []
        coordenadaH = []
        coordenadaV= []
        borrar = []
        vertical = []
        horizontal = [] 
        #Genero cooredenadas de tamaño m*n
        for i in range(0, m):
            for j in range(0, n):
                coordenada.append([i, j])

        #Inido el limite derecho de la maya 
        for fin in range(n-1, len(coordenada), n):
            borrar.append((fin, fin+1))
        
        #Generamos los aristas sobre el lado derecho
        for coordenadaH in range(0, len(coordenada)):
            vertical.append((coordenadaH, coordenadaH+1))
        #eliminamos aritas que no pertenecen a la maya                   
        vetical=list(set(vertical)-set(borrar))
        #generamos la aritas verticales 
        for i in range(0, len(coordenada)):    
            coordenadaV.append((i, i+n))

        #Selecciono las aristas que seran generas para el grafo
        longitud = len(coordenadaV)-n
        s=0
        while s < len(coordenadaV):
            if s == longitud:
                s = len(coordenadaV)
            else:
                horizontal.append(coordenadaV[s])
                s+=1
        self.listaAristas = horizontal + vetical
            
    #Modelo Gn,m de Erdös y Rényi. Crear n nodos y elegir uniformemente al azar m distintos pares de distintos vértices.
    def grafoErdosRenyi(self, n, m, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Erdos-Renyi
        :param n: número de nodos (> 0)
        :param m: número de aristas (>= n-1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        aristarepe = []
        s=0
        
        while s < m: #proporciono el la cantidad de aritrias que se puede generar 
            #Selecciono dos nodos al azar 
            u=rd.randint(1, n) 
            v=rd.randint(1, n)
            #Si estan repetidos realizo otro intento
            if u == v:
                s-=1
            elif u != v:
                nod2= u,v
            if nod2 in aristarepe:
                s-=1
            else:
                aristarepe.append((nod2))
            s+=1
        self.listaAristas = aristarepe
        
    #Modelo Gn,p de Gilbert. Crear n nodos y poner una arista entre cada par independiente y uniformemente con probabilidad p.
    def grafoGilbert(self, n, p, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Gilbert
        :param n: número de nodos (> 0)
        :param p: probabilidad de crear una arista (0, 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado"""
    
        l=list(range(n)) #se genera una lista de nodos

        #Se lee el los nodos y se realiza un cilco for
        l = ([(l,j) 
            for l in range(n)   
                for j in range(l)   
                    if rd.random() < p]) #toma la decisicon mediante un promedio si se realiza union o no mediate un true o False
        
        self.listaAristas = l

    #Modelo Gn,r geográfico simple. Colocar n nodos en un rectángulo unitario con coordenadas 
    #uniformes (o normales) y colocar una arista entre cada par que queda en distancia r o menor.
    def grafoGeografico(self, n, r, x, y, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo geográfico simple
        :param n: número de nodos (> 0)
        :param r: distancia máxima para crear un nodo (0, 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        coor = []
        numNodoCoor = []
        for i in range(x):
            for j in range(y):
                coor.append((i, j))

        # Genera el numero numero del nodos y su cooredenada 
        for i in range(0, len(coor)-1): 
            j = i, coor[i]
            numNodoCoor.append(j)

        nodoGPS = [] # coordenadas en el cuadrado (m*m)-1
        listaNodo =[]
        #Genero lista de nodos posibles 
        for i in range(n-1):
            listaNodo.append(i)

        #genero al azar nodos dentro del limiete de mis coordenadas 
        totalNodos =rd.randint(1, n-1)
        s=0
        while s < totalNodos: #selecciono al azar el nodo
                
            nodo = rd.choice(listaNodo)
            tomoNodo = listaNodo.index(nodo)
            nodoGPS.append(nodo)

            del listaNodo[tomoNodo] #elimino para no tener repetidos 

            s+=1

        listaNodoRadio =[]

        #Asigno el nodos seleccionado con su coordenada
        for i in range(0, len(nodoGPS)):
            j=numNodoCoor[nodoGPS[i]]
            listaNodoRadio.append(j)

        s=0
        nodoOrigen = []
        nodoMapa = []
        while s < totalNodos:
            
            #tomo un nodo de listaNodoRadio y lo agrego a nodoOtogen
            nodoOrigen.append(listaNodoRadio[0])
            #Elimino el nodo listaNodoRadio que tome
            del listaNodoRadio[0]
            #se utilizara el metodo de puntos dnetro de un circulo donde nodoOrigen es el nodo del centro 
            # y listaNodoRadio son los nodos cercanos a ese nodo

            for i in range(0, len(listaNodoRadio)):
                rN = ((listaNodoRadio[i][1][0]-nodoOrigen[s][1][0])**2) + ((listaNodoRadio[i][1][1]-nodoOrigen[s][1][1])**2)
                if rN <= r:
                    nodoMapa.append((nodoOrigen[s][0], listaNodoRadio[i][0]))         
            s+=1

        self.listaAristas = nodoMapa

    #Variante del modelo Gn,d Barabási-Albert. Colocar n nodos uno por uno, asignando a cada uno d aristas a vértices distintos de tal manera
    # que la probabilidad de que el vértice nuevo se conecte a un vértice existente v es proporcional a la cantidad de aristas que v tiene 
    # actualmente - los primeros d vértices se conecta todos a todos.
    def grafoBarabasiAlbert(self, n, d, dirigido=False, auto=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Barabasi-Albert
        :param n: número de nodos (> 0)
        :param d: grado máximo esperado por cada nodo (> 1)
        :param dirigido: el grafo es dirigido?
        :param auto: permitir auto-ciclos?
        :return: grafo generado
        """
        l= n
        m=range(n)

        listaNodos = []
        for i in range(0, len(m)):
            listaNodos.append(i)

        nodoUtiles = []
        listaTemporal = []
        nodoAceptado = []
        nodoRevicion = []
        nodoSeleccionados = []
        s=0
        x=0
        #contrullo tomo cada nodo de la lista
        while s < l: 
            s1 = 0
            for i in listaNodos:
                nodoUtiles.append(i)
            del nodoUtiles[0]

            while s1 < d:

                if s != 0 and s1 == 0:
                    for i  in range(0, len(listaTemporal)):
                        j = listaTemporal[i][1]
                        if j == s:
                            s1+=1
                    
                #reglas de promedio para nueva arista
                if s1 != 0:
                    p = 1-(s1/d)
                else:
                    p = 1
                    c = 0

                # Creo la primera aista
                # Proporciono una probavilidad para unirlos al siguiente nodo o no
                if rd.random() < p: # Si es True lo gurdo
                    if s != nodoUtiles[c]:
                        nodoCandidato = s, nodoUtiles[c] #genero una arista
                        listaTemporal.append(nodoCandidato) #la cargo a una pila
                        nodoSeleccionados.append(s)
                        nodoSeleccionados.append(nodoUtiles[c])
                        del nodoUtiles[c] #elimino 
                    
                else:
                    s1-=1
                    c+=1

                # pregunnro si ya lei todos los nodos del grafo
                if c == len(nodoUtiles):
                    c = 0

                s1+=1
            nodoUtiles = [ ]
            print
            s+=1
        
        self.listaAristas = listaTemporal

    #Modelo Gn Dorogovtsev-Mendes. Crear 3 nodos y 3 aristas formando un triángulo. Después, para cada nodo adicional,
    # se selecciona una arista al azar y se crean aristas entre el nodo nuevo y los extremos de la arista seleccionada. 
    def grafoDorogovtsevMendes(self, n, dirigido=False):
        import random as rd
        """
        Genera grafo aleatorio con el modelo Barabasi-Albert
        :param n: número de nodos (≥ 3)
        :param dirigido: el grafo es dirigido?
        :return: grafo generado
        """
        
        listaNodo = []
        candidatosNodo = []
        trinagulo = []

        for i in range(n):
            listaNodo.append(i)
        
        # Genero un base para conectrar los otros triagulos 
        s = 0
        while s < 3:
        
            nodo = rd.choice(listaNodo)
            tomoNodo = listaNodo.index(nodo)
            candidatosNodo.append(nodo)

            del listaNodo[tomoNodo]

            s+=1
        # Construyo el primer triangulos
        trinagulo.append((candidatosNodo[0], candidatosNodo[1]))
        trinagulo.append((candidatosNodo[1], candidatosNodo[2]))
        trinagulo.append((candidatosNodo[0], candidatosNodo[2]))
        #Se lecciono un nodo de los disponibles y lo uno con dos nodos de mi lista de candidatos
        # se elmina el nodo tomado y se continua asta finalizar todos los nodos
        s1 = 0
        while s1 < len(listaNodo):
            nodoB = rd.choice(listaNodo)
            nodoT = listaNodo.index(nodoB)
            nodo1 = rd.choice(candidatosNodo)
            nodo2 = rd.choice(candidatosNodo)
            if nodo1 != nodo2:
                trinagulo.append((nodo1, nodoT))
                trinagulo.append((nodo2, nodoT))

                del listaNodo[nodoT]
            else:
                s1-=1
            s1+=1
        
        self.listaAristas = trinagulo

class Csv:
    def archivos(self, opcion, listaAristas):
        import pandas as pd
        b = Biblioteca()
        #Genera archivo CSV
        
        lista = listaAristas
        df = pd.DataFrame(lista)
        print(df)
        if opcion == 1:
            df.to_csv('malla.csv', index=False)
        elif opcion == 2:
            df.to_csv('ErdosRenyi.csv', index=False)
        elif opcion == 3:
            df.to_csv('Gilbert.csv', index=False)
        elif opcion == 4:
            df.to_csv('Geográfico.csv', index=False)
        elif opcion == 5:
            df.to_csv('BarabasiAlbert.csv', index=False)
        elif opcion == 6:
            df.to_csv('trinagulo.csv', index=False)

class CsvRecorrido:
    def archivosR(self, recorrerNodo, lista):
        import pandas as pd
        g = Grafo()
        #Genera archivo CSV
        #lista = g.storeR
        print(lista)
        df = pd.DataFrame(lista)
        if recorrerNodo == 1: 
            df.to_csv('BFS.csv', index=False)
        elif recorrerNodo == 2:
            df.to_csv('DFS_R.csv', index=False)
        elif recorrerNodo == 3:
            df.to_csv('DFS_L.csv', index=False)

class NodosAristas:
    def __init__(self):
        self.b = Biblioteca()
        self.g = Grafo()
        self.csvR = CsvRecorrido()
          
    def nodoID(self, n, listaAristas):
        
        #Se prorciona la lista de nodo a la clase nodo
        self.p = n
        self.listaAristas = listaAristas
        for v in range(self.p):
            self.g.agregaNodo(v)

        
        listaAristasL = []
        nodoIDvecinos = [] 
        
        self.listaAristasS  = self.listaAristas
        for i in self.listaAristasS:
            for j in i:
                listaAristasL.append(j)
        
        l = listaAristasL
        for i in range(0,len(l)-1,2):
            self.g.agregarAristas(l[i],l[i+1])
        for v in self.g.vertices:
            print((v, self.g.vertices[v].vecinos))
    #Menu de recorrido por porfundidad o a lo ancho
    def recorrerNodoP(self, recorrerNodo, nodoSeleccionado):
        
        while recorrerNodo != 0:
            self.g.resetear(self.p) #envia tamaño de nodo para realizar el reseteo    
            if recorrerNodo == 1:
                self.g.bfs(nodoSeleccionado) #envia el nodo que servira como referencia
                    
            elif recorrerNodo == 2:
                self.g.dfs_R(nodoSeleccionado)
                
            elif recorrerNodo == 3:
                self.g.dfs_L(nodoSeleccionado)
                
            else:
                print('esa opcion no esta en el menú')
            
            if recorrerNodo > 0 and recorrerNodo < 4:
                generaArchivo = int(input("Generar un archivo CSV \n 1. Si \n 2. No \n"))
                if generaArchivo == 1:
                    self.csvR.archivosR(recorrerNodo, self.g.storeR) #envia a archivosR el tipo la opcion para generara el CSV
            else:
                print('No se generara CSV')  

            recorrerNodo = int(input("0. Ninguno \n 1. Recorrer BFS \n 2. Recorrer DFS_R \n 3. Recorrer DFS_L \n"))           
            if recorrerNodo > 0 and recorrerNodo < 4:
                nodoSeleccionado = int(input("Seleccione un  nodo "))
            else:
                print('Gracias') 

class Menu:
    def __init__(self): 
        import random as rd
        self.b = Biblioteca()
        self.g = Grafo()
        self.c = Csv()
        self.nod = NodosAristas()        
        self.csvR = CsvRecorrido()
    
    def recorrernodos(self):
        recorrerNodo = int(input("0. Ninguno \n 1. Recorrer BFS \n 2. Recorrer DFS_R \n 3. Recorrer DFS_L \n"))
            
        if recorrerNodo > 0 and recorrerNodo < 4:
            nodoSeleccionado = int(input("Seleccione un  nodo "))
            self.nod.recorrerNodoP(recorrerNodo, nodoSeleccionado)
        else:
            print('Gracias')     
    
    def imprimircsv(self, opcion, listaAristas):
        generaArchivo = int(input("Generar un archivo CSV \n 1. Si \n 2. No \n"))
        if generaArchivo == 1:
            self.c.archivos(opcion, listaAristas)
        else:
            print('No hay CSV \n ')

    def opcionesMenu(self, opcion): 
        import random as rd  
        #se obteiene n nodos al azar
        self.n = rd.randint(0, 500)
        while opcion != 0:
            if opcion == 1:
                m= 25 #rd.randint(0, 6)
                n = self.n*m
                print('Graficar la malla')
                self.b.grafoMalla(self.n, m) 
                print(self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.b.listaAristas)
                print('es paso')
                self.nod.nodoID(n, self.b.listaAristas)
                Menu.recorrernodos(self)

            elif opcion == 2:
                m= rd.randint(0, 200)
                print('Graficar la Erdos Renyi')
                self.b.grafoErdosRenyi(self.n, m)
                print(self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.recorrernodos(self)

            elif opcion == 3:
                print('Graficar la Gilbert')
                #Se proporciona un promedio 
                p = 0.25
                self.b.grafoGilbert(self.n, p)
                print(self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.recorrernodos(self)

            elif opcion == 4:
                print('Graficar la Geografico')
                r = int(input("Indique un radio "))
                x = int(input("Indique una longitud x"))
                y = int(input("Indique una altura y"))
                self.b.grafoGeografico(self.n, r, x, y) # es importante generar un cuadrado x y y confome al tamaño de n
                print(self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.recorrernodos(self)

            elif opcion == 5:
                print('Graficar la BarabasiAlbert')
                d = rd.randint(1, self.n-1)
                self.b.grafoBarabasiAlbert(self.n, d)
                print(self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.recorrernodos(self)

            elif opcion == 6:
                print('Graficar la Dorogovtsev Mendes')
                self.b.grafoDorogovtsevMendes(self.n)
                print(self.b.listaAristas)
                Menu.imprimircsv(self, opcion, self.b.listaAristas)
                self.nod.nodoID(self.n, self.b.listaAristas)
                Menu.recorrernodos(self)
            elif opcion == 0:
                print('Gracias')
            else:
                print('esa opcion no esta en el menú')
            
            
            opcion = int(input("Menú Principal: \n 1. Graficar la malla \n 2. Graficar la Erdos Renyi \n 3. Graficar la Gilbert \n 4. Graficar la Geografico \n 5. Graficar la BarabasiAlbert \n 6. Graficar la Dorogovtsev Mendes \n 0. Salir \n"))
                        
class Main:
    me = Menu()
    
    opcion = int(input("Menú Principal: \n 1. Graficar la malla \n 2. Graficar la Erdos Renyi \n 3. Graficar la Gilbert \n 4. Graficar la Geografico \n 5. Graficar la BarabasiAlbert \n 6. Graficar la Dorogovtsev Mendes \n 0. Salir \n"))
    if opcion == 0:
        print('Gracias')
    me.opcionesMenu(opcion)
    

Main()